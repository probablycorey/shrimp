@external propSource highlighting from "./highlight"

@skip { space }

@top Program { item* }

@tokens {
  @precedence { Number "-" }
  
  NamedArgPrefix { $[a-z]+ "=" }
  Number { "-"? $[0-9]+ ('.' $[0-9]+)? }
  Boolean { "true" | "false" }
  String { '\'' ![']* '\'' }
  newlineOrSemicolon { "\n" | ";" }
  eof { @eof }
  space { " " | "\t" }
  leftParen { "(" }
  rightParen { ")" }
  colon[closedBy="end", @name="colon"] { ":" }
  end[openedBy="colon",  @name="end"] { "end" }
  Underscore { "_" }
  "fn" [@name=keyword]
  "if" [@name=keyword]
  "elsif" [@name=keyword]
  "else" [@name=keyword]
  "and" [@name=operator]
  "or" [@name=operator]
  "!=" [@name=operator]
  "<" [@name=operator]
  "<=" [@name=operator]
  ">" [@name=operator]
  ">=" [@name=operator]
  "=" [@name=operator]
  "+"[@name=operator]
  "-"[@name=operator]
  "*"[@name=operator]
  "/"[@name=operator]
  "|"[@name=operator]
}

@external tokens tokenizer from "./tokenizer" { Identifier, Word }

@precedence {
  pipe @left,
  multiplicative @left,
  additive @left,
  call
}

item { 
  consumeToTerminator newlineOrSemicolon |
  consumeToTerminator eof |
  newlineOrSemicolon // allow blank lines
}


consumeToTerminator {
  PipeExpr |
  ambiguousFunctionCall |
  IfExpr |
  FunctionDef |
  Assign |
  BinOp |
  expressionWithoutIdentifier
}

PipeExpr {
  pipeOperand (!pipe "|" pipeOperand)+
}

pipeOperand {
  FunctionCall | FunctionCallOrIdentifier
}

FunctionCallOrIdentifier {
  Identifier
}

ambiguousFunctionCall {
  FunctionCall | FunctionCallOrIdentifier
}

FunctionCall {
  Identifier arg+
}

arg {
  PositionalArg | NamedArg
}


PositionalArg {
  expression | FunctionDef | Underscore
}

NamedArg {
  NamedArgPrefix (expression | FunctionDef | Underscore)
}

FunctionDef {
  singleLineFunctionDef | multilineFunctionDef
}

singleLineFunctionDef {
  "fn" Params colon consumeToTerminator end
}

multilineFunctionDef {
  "fn" Params colon newlineOrSemicolon block end
}

IfExpr {
  singleLineIf | multilineIf
}

singleLineIf {
  "if" (ConditionalOp | expression) colon ThenBlock { consumeToTerminator }
}

multilineIf {
  "if" (ConditionalOp | expression) colon newlineOrSemicolon ThenBlock ElsifExpr* ElseExpr? end
}

ElsifExpr {
  "elsif" (ConditionalOp | expression) colon newlineOrSemicolon ThenBlock
}

ElseExpr {
  "else" colon newlineOrSemicolon ThenBlock
}

ThenBlock {
  block
}

ConditionalOp {
  expression "=" expression |
  expression "!=" expression |
  expression "<" expression |
  expression "<=" expression |
  expression ">" expression |
  expression ">=" expression |
  expression "and" (expression | ConditionalOp) |
  expression "or" (expression | ConditionalOp)
}

Params {
  Identifier*
}

Assign {
  Identifier "=" consumeToTerminator
}

BinOp {
  (expression | BinOp) !multiplicative "*" (expression | BinOp) |
  (expression | BinOp) !multiplicative "/" (expression | BinOp) |
  (expression | BinOp) !additive "+" (expression | BinOp) |
  (expression | BinOp) !additive "-" (expression | BinOp)
}

ParenExpr {
  leftParen (ambiguousFunctionCall | BinOp | expressionWithoutIdentifier | ConditionalOp | PipeExpr) rightParen
}

expression {
  expressionWithoutIdentifier | Identifier
}

// We need expressionWithoutIdentifier to avoid conflicts in consumeToTerminator.
// Without this, when parsing "my-var" at statement level, the parser can't decide:
//   - ambiguousFunctionCall → FunctionCallOrIdentifier → Identifier
//   - expression → Identifier  
// Both want the same Identifier token! So we use expressionWithoutIdentifier
// to remove Identifier from the second path, forcing standalone identifiers
// to go through ambiguousFunctionCall (which is what we want semantically).
// Yes, it is annoying and I gave up trying to use GLR to fix it.
expressionWithoutIdentifier {
  ParenExpr | Word | String | Number | Boolean
}

block {
  (consumeToTerminator newlineOrSemicolon)*
}